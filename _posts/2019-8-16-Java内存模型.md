---
layout: post
title: Java内存模型
---
Java内存模型(Java Memory Model)定义了程序中变量的访问规则, 如怎么从内存中读取数据、怎么将数据写入内存这样的细节操作.
## 背景
由于CPU计算速度远超磁盘IO, 为了近一步压榨CPU计算能力提出使用多线程方法. 下图展示了硬件模型的架构, 虽然想法简单但会遇到两个难点, 其一是CPU需要与内存交互, 其二是CPU与磁盘速度差距过大, 需要引入缓存机制来近一步提高效率, 由于不同CPU拥有不同缓存, 此时会涉及到更新缓存至内存时的缓存一致性问题, 也就是不知道该采用谁的缓存.
![_config.yml]({{ site.baseurl }}/images/HMM.png)


## 内存布局
Java将内存模型分为主内存与工作内存, 如下图所示. 其中, 每个线程拥有一个工作内存, 所有线程共用一个主内存. 线程只能在工作内存中写入数据, 不能直接在主内存中写入;工作内存之间无法直接通信, 需要通过主内存来通信

## 基本操作
Java定义了一系列变量访问规则, 比如read, load, store, write, lock, unlock等操作, 此处不深入讲解

## volatile关键字
volatile是最轻量级的同步机制, volatile关键字有两个用途. 其一是, 保证了变量的可见性, 当某个线程更改了某变量的值以后都将会及时更新在主内存中以供其他线程观察. 其二是, 保证了有序性, 静止了指令的重排序优化, 保证了在volatile之后的指令不会在该指令之前执行.
原理: volatile关键字在完成赋值之后将会产生一条lock xxx的字节码, 此条字节码将会产生一个内存屏障, 使得之后的指令不会在此之前被执行, 并且该指令执行之后就会立马更新变量到主内存中, 既然要更新那么之前操作必定完成, 即近一步说明了可见性.
这里需要注意的是volatile变量并无法保证线程安全, 如++i, 即便i是volatile, 但是++操作分为读取、计算、赋值三步, 并不是原子操作.

## float与double类型
对于Java中的基础变量通常均为原子操作, 而float、double具有64位, jvm并未规定这两个类型变量需要原子操作, 也可以将其变为2个32位来操作, 即可能发生写入了一半的数据就被读取的事情, 但这种情况极少发生, 商业化的虚拟机都将其实现为了原子操作.

## 原子性、可见性、有序性
在Java多线程中, 通常解决的线程安全问题都针对原子性、可见性、有序性这三个特性, 接下来我们看看Java内存模型是如何实现这三种类型的.
原子性: 上面提到过基础类型通常具有原子性(float、double)较为特殊, 而若要对一段代码实现原子操作, 则需要利用synchronized关键字, 将程序执行退化为单线程使得在执行过程中不会有其他线程打扰, 以保证操作的原子性.
可见性: 上面提到过volatile使得变量具有可见性, 而synchronized与final也具有可见性; synchronized关键字在释放锁的同时将会把数据写会内存以实现可见性, 由于final是常量, 因此在类被加载的加载过程中就被赋值, 之后一直为可见.
有序性: 上面提到过volatile可以禁止指令重排序优化, 因此可以实现有序性. 另一种方式是采用synchronized关键字, 使程序退化为单线程, 其中Java单线程为天然有序的, 因此可以满足有序性.
此处可以发现synchronized关键字可以满足三大特性, 但是大多数情况下volatile更轻量级, 但由于jvm对synchronized进行了大量优化.

## 先行发生原则
若Java中所有的次序都要通过synchronized与volatile来实现会非常繁琐, 因此设计了一系列的先行原则作为自然顺序, 这里列举几个
1. 程序次序规则, 在单线程中总是按照控制流来执行顺序.
2. volatile变量规则, volatile变量在写入的过程中, 下一次被读取一定要等到这次写入完成.
3. 管程锁定规则, 一个unlock操作一定先行发生于后面一个lock操作(对同一个锁而言, 如synchronized).
4. 线程启动、终止规则, 一个线程的start操作一定最早, 而终止操作一定最晚.
